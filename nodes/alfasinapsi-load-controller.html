<style>
	/* Make form fields more compact (keep whitespace on the right) */
	#node-input-name {
		width: 420px;
		max-width: 100%;
	}

	#node-input-name {
		width: 360px;
	}

	.alfasinapsi-loads .red-ui-editableList-container {
		min-height: 240px;
	}

	.alfasinapsi-loads-title {
		margin-top: 10px;
		margin-bottom: 4px;
		font-weight: 600;
	}

	.alfasinapsi-loads-title i {
		margin-right: 6px;
	}

	.alfasinapsi-loads-container {
		display: block;
		width: 100%;
		/* Fixed-width columns keep the inputs compact (extra space remains on the right). */
		--alfasinapsi-load-cols: minmax(220px, 320px) 130px 130px;
		--alfasinapsi-load-gap: 2px;
	}

	.alfasinapsi-loads-columns {
		display: grid;
		grid-template-columns: var(--alfasinapsi-load-cols);
		gap: var(--alfasinapsi-load-gap);
		width: fit-content;
		padding-left: 28px;
		/* draggable handle space */
		padding-right: 40px;
		/* remove button space */
		margin-bottom: 6px;
		font-size: 12px;
		opacity: 0.75;
		box-sizing: border-box;
	}

	.alfasinapsi-loads-columns div {
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}

	.alfasinapsi-load-row {
		display: grid;
		grid-template-columns: var(--alfasinapsi-load-cols);
		gap: var(--alfasinapsi-load-gap);
		width: fit-content;
		align-items: center;
	}

	.alfasinapsi-load-row input {
		width: 100% !important;
		min-width: 0;
		box-sizing: border-box;
	}

	/* Reduce extra vertical padding added by editableList */
	.alfasinapsi-loads .red-ui-editableList-item-content {
		padding-top: 6px;
		padding-bottom: 6px;
	}
</style>

<script type="text/html" data-template-name="alfasinapsi-load-controller">
		  <div class="form-row">
		    <label><i class="fa fa-youtube-play" style="color:#ff0000;"></i> Video</label>
		    <a href="https://youtu.be/R-7PZv3iJ2s" target="_blank" rel="noopener noreferrer">Guarda su YouTube</a>
		  </div>

		  <div class="form-row">
		    <label for="node-input-name"><i class="fa fa-tag"></i> Nome</label>
		    <input type="text" id="node-input-name" placeholder="controller carichi">
		  </div>

	  <div class="form-row alfasinapsi-loads-title">
	    <span><i class="fa fa-list"></i> Carichi</span>
	  </div>
  <div class="form-row alfasinapsi-loads">
    <input type="hidden" id="node-input-loads">
    <div class="alfasinapsi-loads-container">
		      <div class="alfasinapsi-loads-columns">
		        <div>Nome (ordine = priorita)</div>
		        <div>Min acceso (s)</div>
		        <div>Min spento (s)</div>
		      </div>
	      <ol id="node-input-loads-list"></ol>
	    </div>
	  </div>
</script>

<script type="text/html" data-help-name="alfasinapsi-load-controller">
	  <p>
	    <b>Sinapsi Alfa load controller</b> gestisce uno <b>shedding stage</b> (0..N) usando i messaggi in formato <b>Telemetria</b>.
	    In particolare usa <code>msg.payload.cutoff.hasWarning</code> per incrementare/decrementare lo stage.
	  </p>

	  <h3>Video YouTube</h3>
	  <p><a href="https://youtu.be/R-7PZv3iJ2s" target="_blank" rel="noopener noreferrer">Guarda il video: configurazione e utilizzo</a></p>

  <h3>Importante</h3>
  <p>
    Questo nodo <b>non comanda i rele</b> da solo.
    Collega ogni uscita carico a qualcosa che possa davvero abilitare/disabilitare dispositivi (MQTT, Shelly, chiamate Home Assistant, ecc.).
  </p>

		  <h3>Ingressi</h3>
		  <p>Questo nodo ha 1 ingresso.</p>
		  <dl class="message-properties">
		    <dt>Shedding</dt>
		    <dd>
	      Questo nodo accetta solo messaggi in formato <b>Telemetria</b> (output del nodo <code>alfasinapsi-telemetry</code> in modalita <i>Telemetria</i>).
	      Usa <code>msg.payload.cutoff.hasWarning</code> (<code>true</code>/<code>false</code>) per decidere se incrementare o decrementare lo stage.
	      <p>
	        Nota: lo <b>stage cambia di 1 per ogni messaggio</b> ricevuto. Quindi la velocita dello shedding dipende dalla frequenza dei messaggi in ingresso
	        (per esempio dipende dal <i>Poll (ms)</i> del nodo <code>alfasinapsi-telemetry</code>).
		      </p>
		    </dd>
		  </dl>

	  <h3>Uscite</h3>
	  <p>
	    Il numero di uscite e' pari al numero di carichi configurati (minimo 1, per evitare che il nodo sparisca dall'editor).
	    Ogni uscita corrisponde al carico nella stessa posizione in lista.
	  </p>

	  <h3>Sequenza a stadi</h3>
	  <p>
	    Lo stage indica quanti carichi sono in shedding: vengono disabilitati i primi <code>stage</code> carichi in base all'<b>ordine</b> della lista.
	    Quindi: il primo carico in lista viene shed per primo, l'ultimo viene shed per ultimo (e viene ripristinato per primo durante <code>unshed</code>).
	  </p>
	  <p>
	    I timer <i>Min acceso</i>/<i>Min spento</i> limitano le commutazioni e vengono sempre rispettati.
	  </p>

	  <h3>Messaggio comando per carico</h3>
	  <dl class="message-properties">
	    <dt>msg.topic <span class="property-type">string</span></dt>
	    <dd>Nome del carico (es. <code>Lavastoviglie</code>).</dd>

	    <dt>msg.payload <span class="property-type">boolean</span></dt>
	    <dd><code>true</code> = unshed/abilitato, <code>false</code> = shed/disabilitato.</dd>
	  </dl>

  <h3>Configurazione</h3>
  <dl class="message-properties">
    <dt>Carichi <span class="property-type">list</span></dt>
    <dd>Lista dei carichi (vedi sotto).</dd>
  </dl>

  <h3>Configurazione carichi</h3>
  <dl class="message-properties">
    <dt>Nome <span class="property-type">string</span></dt>
    <dd>Identificativo del carico. Usato anche come etichetta di uscita e come <code>msg.topic</code> in output.</dd>

    <dt>Ordine <span class="property-type">list position</span></dt>
    <dd>La posizione nella lista determina la priorita (dall'alto verso il basso).</dd>

    <dt>Min acceso (s) / Min spento (s) <span class="property-type">number</span></dt>
    <dd>Timer anti-commutazione per evitare accensioni/spegnimenti troppo frequenti.</dd>
  </dl>
</script>

<script type="text/javascript">
	(function () {
		function loadDefaults() {
			return { name: "carico", minOnSec: 0, minOffSec: 0 };
		}

		function safeParseLoads(value) {
			if (Array.isArray(value)) return value;
			if (typeof value !== "string") return [];
			try {
				const parsed = JSON.parse(value || "[]");
				return Array.isArray(parsed) ? parsed : [];
			} catch (e) {
				return [];
			}
		}

		function normaliseLoads(list) {
			return (list || []).filter(l => l && l.name);
		}

		RED.nodes.registerType('alfasinapsi-load-controller', {
			category: 'AlfaSinapsi Ultimate',
			color: '#00BAFF',
			defaults: {
				name: { value: "" },
				loads: { value: "[]" },
				outputs: { value: 1 }
			},
			inputs: 1,
			outputs: 1,
			outputLabels: function (index) {
				try {
					const loads = normaliseLoads(safeParseLoads(this.loads));
					const l = loads[index];
					return l ? l.name : ("carico " + (index + 1));
				} catch (e) {
					return ("carico " + (index + 1));
				}
			},
			icon: "font-awesome/fa-toggle-on",
			label: function () { return this.name || "alfasinapsi controller carichi"; },
			onadd: function () {
				const updateOutputs = () => {
					try {
						const loads = normaliseLoads(safeParseLoads(this.loads));
						const next = Math.max(1, loads.length);
						if (this.outputs !== next) this.outputs = next;
						if (Array.isArray(this.wires)) {
							while (this.wires.length < this.outputs) this.wires.push([]);
						}
					} catch (e) {
						this.outputs = 1;
					}
					try {
						RED.view?.redraw?.();
					} catch (e) {
						// ignore
					}
				};
				updateOutputs();
				// Defer once so `this.loads` is reliably populated when loading flows at startup.
				setTimeout(updateOutputs, 0);
			},
			oneditprepare: function () {
				const list = $("#node-input-loads-list");
				const loads = normaliseLoads(safeParseLoads(this.loads));

				function writeBack() {
					const items = [];
					list.editableList('items').each(function (i) {
						const row = $(this);
						items.push({
							name: row.find(".alf-name").val(),
							minOnSec: Number(row.find(".alf-minon").val()),
							minOffSec: Number(row.find(".alf-minoff").val())
						});
					});
					$("#node-input-loads").val(JSON.stringify(normaliseLoads(items)));
				}

				list.editableList({
					addButton: true,
					removable: true,
					sortable: true,
					addItem: function (container, i, data) {
						const d = $.extend(loadDefaults(), data);
						const row = $('<div class="alfasinapsi-load-row"></div>').appendTo(container);

						$('<input type="text" class="alf-name" placeholder="Nome">').val(d.name).appendTo(row);
						$('<input type="number" class="alf-minon" placeholder="Min acceso (s)">').val(d.minOnSec).appendTo(row);
						$('<input type="number" class="alf-minoff" placeholder="Min spento (s)">').val(d.minOffSec).appendTo(row);

						row.find("input").on("change keyup", writeBack);
						writeBack();
					},
					removeItem: function () { writeBack(); },
					sortItems: function () { writeBack(); }
				});

				loads.forEach(l => list.editableList('addItem', l));
				writeBack();
			},
			oneditsave: function () {
				try {
					const loads = normaliseLoads(safeParseLoads($("#node-input-loads").val() || "[]"));
					this.outputs = Math.max(1, loads.length);
					if (Array.isArray(this.wires)) {
						while (this.wires.length < this.outputs) this.wires.push([]);
					}
				} catch (e) {
					this.outputs = 1;
				}
			}
		});
	})();
</script>
